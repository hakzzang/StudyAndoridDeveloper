### 4-1. 스트림 정의

#### 스트림과 컬렉션의 차이점

컬렉션은 자료구조이다. 그래서 ArrayList, LinkedList를 사용할 지에 대한 시간과 공간의 복잡성과 관련된 요소가 주를 이룬다.컬렉션의 주제는 데이터이다.

스트림은 filter, sorted, map처럼 표현 계산식이 주를 이룬다. 스트림의 주제는 계산이다.

#### 스트림과 컬렉션의 차이점2(p144)
 책 속의 필자는 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이라고 한다. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조, 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조라고 설명하고 있다.
 
 이에 대해서, DVD영화와 스트리밍 영화를 예로 들었는데, DVD에 담겨진 영화는 모든 영화에 대한 정보가 다 담겨져 있는데, 스트리밍으로 영화를 볼 때는 시청하고 싶은 특정 프레임부터 정보를 갖고 있기에 이러한 점이 컬렉션과 스트림의 차이라고 이야기하고 있다.
 즉, 스트림은 게으르게 만들어지는 컬렉션으로 사용자가 데이터를 요청할 때만 값을 계산한다. 이를 '요청 중심 제조'라고 부른다고 한다.
 컬렉션은 '생산자 중심'으로 창고를 가득 채우고 물건을 주는 것을 의미한다고 설명하고 있다.

 확실히, 이러한 설명과 그림자료는 스트림과 컬렉션의 차이를 확실하게 인식하게 도와준다. 이 책의 장점이라고 생각되어진다.

#### 스트림의 특성

1. 선언형 : 간결하고, 가독성이 좋다
2. 조립성 : 유연하다.
3. 병렬화 : 성능이 좋아진다.

스트림은 선언 가능하고, 조립이 가능하고, 병렬적인 특성을 갖고 있다.
스트림의 정의는 '데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소'라고 정의한다고 한다.

스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다. 정렬된 컬렉션으로 생성하면, 정렬이 그대로 유지된다. 즉, 스트림의 요소는 생성한 것에 따른다.

스트림은 함수현 프로그램에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다. filter, map, reduce, find, match, 병렬 실행등을 제공한다.

 
### 4-2. 스트림 사용하기

Example
```java
import static java.util.stream.Collectors.toList;
List<String> todayMails = mails
          .stream()
          .filter(mail -> mail.dateAt == today)
          .map(Mail::getName)
          .limit(10)
          .collect(toList());
System.out.println(todayMails.toString());
```
정말 좋은 예제가 책에 수록되어 있지만, 공부를 위해서 예제를 변경했습니다. '받은 메일함에서 오늘 온 메일의 이름들을 10개씩 보고 싶다'라는 것을 통해서 데이터를 처리하려고 합니다.

stream()을 통해서, filter, map, limit, collect의 일련의 데이터 처리 연산을 처리할 수 있다. 이 때, collect를 제외한 모든 연산은 파이프라인을 형성해서 스트림을 반환한다.
여기에서 파이프라인이란 소스에 적용하는 질의이다. 즉, collect가 호출하기 전까지는 아무 데이터를 볼 수 없다.

• filter() : 람다식을 인수로 받아서, 스트림에서 조건에 맞는 특성 요소를 선택한다.
• map() : 람다를 이용해서 한 요소를 다른 요소로 변환하거 정보를 추출한다. 우리는 mail이라는 객체를 mail.getName()을 통해서 String으로 변환해서 정보를 추츨했다.
• limit() : 스트림에 대한 결과에 대한 갯수에 대한 제한을 정의한다.
• collect() : 스트림은 다른 형식으로 변환한다. 여기서 toList()는 스트림을 List로 변환하라는 인수이다.

=================================================

```java
//만약에 컬렉션을 사용했다면,
private List<Mail> getTodayMails() {
   List<Mail> todayMails = new ArrayList<>();
   for(Mail mail : mails){
      if(mail.getDateAt() == today){
          todayMails.add(mail.getName());
          if(todayMails.size() == 10){
             break;    
          }              
      }
   }
   return todayMails;
}
```
 확실히 가독성 측면에서 많이 좋아진 것을 알 수 있다. 그리고 해당 코드에 다른 조건을 붙이더라도 유연하다는 특성을 충족시킨다는 것을 알 수 있다.

### 4-3. 스트림의 고유 특성
 - 딱 한 번만 탐색할 수 있는 속성
 탐색된 스트림의 요소는 소비된다. 그래서, 스트림은 딱 한 번만 탐새할 수 있다. 만약, 2번 탐새을 한다면, 스트림은 java.lang.IllegalStateException으로 오류를 띄운다.

- 내부 반복의 속성
 스트림은 내부 반복이라는 특징을 갖고 있다. 우선, 외부 반복과 내부 반복이 있는데, 외부 반복이랑 for-each를 생각하면 쉽다.
```java
 for(Mail mail : mails){
    mailNames.add(mail.getName());
 }
```
이와 같이 컬렉션을 탐색할 때, mail객체가 노출되게 된다. 이것을 외부 반복이라고 한다. stream을 할 때는, 현재 열려져있는 파이프라인을 통해서 로직을 처리하기 때문에, 비교적 최적화되게 행위를 처리할 수 있다.
 책에서는 그 외에도, 병렬성 관리에 대해서 설명하고 있다.

### 4-4. 스트림 연산

#### 중간 연산

스트림은 중간 연산과 최종 연산으로 구분되어진다. 4-2에서 사용했던 로직에서 filter, map, limit과 같이 사용하는 스트림을 처리해서 계속해서 넘겨준다. 이것은 중간 연산을 통해서 질의를 만드는 것이다.
 또한, 파이프라인이 실행하기 전까지는 아무것도 실행하지 않기 때문에 lazy한 특성을 갖고 있다.
• filter : Stream<T> filter(Predicate<T> p), T -> boolean 
• map : Stream<R> map(Function<T,R> f), T -> R
• limit : Stream<T> limit()
• sorted : Stream<T> sorted(Comprator<T> c), (T,T) -> int
• distinct : Stream<T> distinct()

#### 최종 연산
 최종 연산은 스트림 파이프라인에서 결과를 도출하는 것이다.
 스트림 파이프라인은 빌더 패턴과 흡사하다. 빌더 패턴은 다양한 속성값을 갖고 있는 특정 객체를 만들 때, 생성자를 여러개를 만드는 패턴에서 벗어나기 위해서 사용하는 효율적인 디자인패턴이다.
 객체의 다양한 속성을 계속해서 연결하다가 build() 메소드를 호출해서 최종적인 객체를 만든다.
 최종 연산 또한, 이와 같이 collect()를 통해서 최종적인 객체를 만드는 것에서 유사하다.
• forEach : 스트림의 각 요소를 소비하면서 람다를 적용한다.
• count : 스트림의 요소 개수를 반환한다.
• collect : 스트림을 리듀스해서 리스트, 맵, 정수 형식의 컬렉션을 만든다.